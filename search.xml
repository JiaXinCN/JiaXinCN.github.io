<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[美化桌面图标]]></title>
    <url>%2F2019%2F04%2F30%2F%E7%BE%8E%E5%8C%96%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[图标下载图标请到以下网址下载： https://una.im/gradient-folders/ 更换图标 以下设置是在 win10 系统下修改的。 新建文件夹，并重命名。 右键文件夹，进入属性选项。 选择 自定义-更改图标 。 选择图标就可以了，在步骤 2 中有展示。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>图标美化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python计算环境--NumPy（二）]]></title>
    <url>%2F2019%2F04%2F30%2FPython%E8%AE%A1%E7%AE%97%E7%8E%AF%E5%A2%83-NumPy%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数组操作Numpy 中包含了一些函数用于处理数据，大概可分为以下几类： 修改数组形状 翻转数组 修改数组维度 连接数组 分割数组 数组元素的添加与删除 修改数组形状 函数 描述 reshape 不改变数据的条件下修改形状 flat 数组元素迭代器 flatten 返回一份数组拷贝，对拷贝所做的修改不会影响原始数组 ravel 返回展开数组 numpy.reshape 函数1numpy.reshape(arr, newshape, order='C') arr：要修改形状的数组 newshape：整数或者整数数组，新的形状应当兼容原有形状 order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’k’ – 元素在内存中的出现顺序。 12345678910import numpy as np a = np.arange(8)print ('原始数组：')print (a)print ('\n') b = a.reshape(4,2)print ('修改后的数组：')print (b) numpy.ndarray.flatnumpy.ndarray.flat 是一个数组元素迭代器，实例如下： 1234567891011import numpy as np a = np.arange(9).reshape(3,3) print ('原始数组：')for row in a: print (row) #对数组中每个元素都进行处理，可以使用flat属性，该属性是一个数组元素迭代器：print ('迭代后的数组：')for element in a.flat: print (element) numpy.ndarray.flattennumpy.ndarray.flatten 返回一份数组拷贝，对拷贝所做的修改不会影响原始数组，格式如下： 1ndarray.flatten(order='C') order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’K’ – 元素在内存中的出现顺序。 123456789101112131415import numpy as np a = np.arange(8).reshape(2,4) print ('原数组：')print (a)print ('\n')# 默认按行 print ('展开的数组：')print (a.flatten())print ('\n') print ('以 F 风格顺序展开的数组：')print (a.flatten(order = 'F')) num.ravelnumpy.ravel() 展平的数组元素，顺序通常是”C风格”，返回的是数组视图（view，有点类似 C/C++引用reference的意味），修改会影响原始数组。 1numpy.ravel(a, order='C') order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’K’ – 元素在内存中的出现顺序。 1234567891011121314import numpy as np a = np.arange(8).reshape(2,4) print ('原数组：')print (a)print ('\n') print ('调用 ravel 函数之后：')print (a.ravel())print ('\n') print ('以 F 风格顺序调用 ravel 函数之后：')print (a.ravel(order = 'F')) 翻转数组 函数 描述 transpose 对换数组的维度 ndarray.T 和 self.transpose() 相同 rollaxis 向后滚动指定的轴 swapaxes 对换数组的两个轴 numpy.transposenumpy.transpose 函数用于对换数组的维度： 1numpy.transpose(arr, axes) arr：要操作的数组 axes：整数列表，对应维度，通常所有维度都会对换。 12345678910import numpy as np a = np.arange(12).reshape(3,4) print ('原数组：')print (a )print ('\n') print ('对换数组：')print (np.transpose(a)) numpy.ndarray.T12345678910import numpy as np a = np.arange(12).reshape(3,4) print ('原数组：')print (a)print ('\n') print ('转置数组：')print (a.T) numpy.rollaxisnumpy.rollaxis 函数向后滚动特定的轴到一个特定位置： 1numpy.rollaxis(arr, axis, start) arr：数组 axis：要向后滚动的轴，其它轴的相对位置不会改变 start：默认为零，表示完整的滚动。会滚动到特定位置。 1234567891011121314151617import numpy as np # 创建了三维的 ndarraya = np.arange(8).reshape(2,2,2) print ('原数组：')print (a)print ('\n')# 将轴 2 滚动到轴 0（宽度到深度） print ('调用 rollaxis 函数：')print (np.rollaxis(a,2))# 将轴 0 滚动到轴 1：（宽度到高度）print ('\n') print ('调用 rollaxis 函数：')print (np.rollaxis(a,2,1)) numpy.swapaxesnumpy.rollaxis 函数向后滚动特定的轴到一个特定位置： 1numpy.rollaxis(arr, axis, start) arr：输入的数组 axis1：对应第一个轴的整数 axis2：对应第二个轴的整数 123456789101112import numpy as np # 创建了三维的 ndarraya = np.arange(8).reshape(2,2,2) print ('原数组：')print (a)print ('\n')# 现在交换轴 0（深度方向）到轴 2（宽度方向） print ('调用 swapaxes 函数后的数组：')print (np.swapaxes(a, 2, 0) 修改数组维度 函数 描述 broadcast 产生模仿广播的对象 broadcast_to 将数组广播到新形状 expand_dims 扩展数组的形状 squeeze 从数组的形状中删除一维条目 numpy.broadcastnumpy.broadcast 用于模仿广播的对象，它返回一个对象，该对象封装了将一个数组广播到另一个数组的结果。 12345678910111213141516171819202122232425262728293031323334353637import numpy as np x = np.array([[1], [2], [3]])y = np.array([4, 5, 6]) # 对 y 广播 xb = np.broadcast(x,y) # 它拥有 iterator 属性，基于自身组件的迭代器元组 print ('对 y 广播 x：')r,c = b.iters # Python3.x 为 next(context) ，Python2.x 为 context.next()print (next(r), next(c))print (next(r), next(c))print ('\n')# shape 属性返回广播对象的形状 print ('广播对象的形状：')print (b.shape)print ('\n')# 手动使用 broadcast 将 x 与 y 相加b = np.broadcast(x,y)c = np.empty(b.shape) print ('手动使用 broadcast 将 x 与 y 相加：')print (c.shape)print ('\n')c.flat = [u + v for (u,v) in b] print ('调用 flat 函数：')print (c)print ('\n')# 获得了和 NumPy 内建的广播支持相同的结果 print ('x 与 y 的和：')print (x + y) numpy.broadcast_tonumpy.broadcast_to 函数将数组广播到新形状。它在原始数组上返回只读视图。 它通常不连续。 如果新形状不符合 NumPy 的广播规则，该函数可能会抛出ValueError。 1numpy.broadcast_to(array, shape, subok) 12345678910import numpy as np a = np.arange(4).reshape(1,4) print ('原数组：')print (a)print ('\n') print ('调用 broadcast_to 函数之后：')print (np.broadcast_to(a,(4,4))) numpy.expand_dimsnumpy.expand_dims 函数通过在指定位置插入新的轴来扩展数组形状，函数格式如下: 1numpy.expand_dims(arr, axis) 参数说明： arr：输入数组 axis：新轴插入的位置 12345678910111213141516171819202122232425262728import numpy as np x = np.array(([1,2],[3,4])) print ('数组 x：') print (x) print ('\n') y = np.expand_dims(x, axis = 0) print ('数组 y：') print (y) print ('\n') print ('数组 x 和 y 的形状：') print (x.shape, y.shape) print ('\n') # 在位置 1 插入轴 y = np.expand_dims(x, axis = 1) print ('在位置 1 插入轴之后的数组 y：') print (y) print ('\n') print ('x.ndim 和 y.ndim：') print (x.ndim,y.ndim) print ('\n') print ('x.shape 和 y.shape：') print (x.shape, y.shape) 输出结果为： 123456789101112131415161718192021数组 x：[[1 2] [3 4]]数组 y：[[[1 2] [3 4]]]数组 x 和 y 的形状：(2, 2) (1, 2, 2)在位置 1 插入轴之后的数组 y：[[[1 2]] [[3 4]]]x.ndim 和 y.ndim：2 3x.shape 和 y.shape：(2, 2) (2, 1, 2) numpy.squeezenumpy.squeeze 函数从给定数组的形状中删除一维的条目，函数格式如下： 1numpy.squeeze(arr, axis) 参数说明： arr：输入数组 axis：整数或整数元组，用于选择形状中一维条目的子集 1234567891011121314import numpy as np x = np.arange(9).reshape(1,3,3) print ('数组 x：') print (x) print ('\n') y = np.squeeze(x) print ('数组 y：') print (y) print ('\n') print ('数组 x 和 y 的形状：') print (x.shape, y.shape) 输出结果为： 123456789101112数组 x：[[[0 1 2] [3 4 5] [6 7 8]]]数组 y：[[0 1 2] [3 4 5] [6 7 8]]数组 x 和 y 的形状：(1, 3, 3) (3, 3) 连接数组 函数 描述 concatenate 连接沿现有轴的数组序列 stack 沿着新的轴加入一系列数组 hstack 水平堆叠序列中的数组（列方向） vstack 竖直堆叠序列中的数组（行方向） numpy.concatenatenumpy.concatenate 函数用于沿指定轴连接相同形状的两个或多个数组，格式如下： 1numpy.concatenate((a1, a2, ...), axis) 参数说明： a1, a2, ...：相同类型的数组 axis：沿着它连接数组的轴，默认为 0123456789101112131415161718import numpy as np a = np.array([[1,2],[3,4]]) print ('第一个数组：') print (a) print ('\n') b = np.array([[5,6],[7,8]]) print ('第二个数组：') print (b) print ('\n') # 两个数组的维度相同 print ('沿轴 0 连接两个数组：') print (np.concatenate((a,b))) print ('\n') print ('沿轴 1 连接两个数组：') print (np.concatenate((a,b),axis = 1)) 输出结果为： 1234567891011121314151617第一个数组：[[1 2] [3 4]]第二个数组：[[5 6] [7 8]]沿轴 0 连接两个数组：[[1 2] [3 4] [5 6] [7 8]]沿轴 1 连接两个数组：[[1 2 5 6] [3 4 7 8]] numpy.stacknumpy.stack 函数用于沿新轴连接数组序列，格式如下： 1numpy.stack(arrays, axis) 参数说明： arrays相同形状的数组序列 axis：返回数组中的轴，输入数组沿着它来堆叠1234567891011121314151617import numpy as np a = np.array([[1,2],[3,4]]) print ('第一个数组：') print (a) print ('\n') b = np.array([[5,6],[7,8]]) print ('第二个数组：') print (b) print ('\n') print ('沿轴 0 堆叠两个数组：') print (np.stack((a,b),0)) print ('\n')print ('沿轴 1 堆叠两个数组：') print (np.stack((a,b),1)) 输出结果如下： 123456789101112131415161718192021第一个数组：[[1 2] [3 4]]第二个数组：[[5 6] [7 8]]沿轴 0 堆叠两个数组：[[[1 2] [3 4]] [[5 6] [7 8]]]沿轴 1 堆叠两个数组：[[[1 2] [5 6]] [[3 4] [7 8]]] numpy.hstacknumpy.hstack 是 numpy.stack 函数的变体，它通过水平堆叠来生成数组。 12345678910111213141516import numpy as np a = np.array([[1,2],[3,4]]) print ('第一个数组：') print (a) print ('\n') b = np.array([[5,6],[7,8]]) print ('第二个数组：') print (b) print ('\n') print ('水平堆叠：') c = np.hstack((a,b)) print (c) print ('\n') 输出结果如下：12345678910111213第一个数组：[[1 2] [3 4]]第二个数组：[[5 6] [7 8]]水平堆叠：[[1 2 5 6] [3 4 7 8]] numpy.vstacknumpy.vstack 是 numpy.stack 函数的变体，它通过垂直堆叠来生成数组。 1234567891011121314import numpy as np a = np.array([[1,2],[3,4]]) print ('第一个数组：') print (a) print ('\n') b = np.array([[5,6],[7,8]]) print ('第二个数组：') print (b) print ('\n')print ('竖直堆叠：') c = np.vstack((a,b)) print (c) 输出结果为： 123456789101112131415第一个数组：[[1 2] [3 4]]第二个数组：[[5 6] [7 8]]竖直堆叠：[[1 2] [3 4] [5 6] [7 8]] 分割数组 函数 描述 split 将一个数组分割为多个子数组 hsplit 将一个数组水平分割为多个子数组（按列） vsplit 将一个数组垂直分割为多个子数组（按行） 数组元素的添加与删除 函数 描述 resize 返回指定形状的新数组 append 将值添加到数组末尾 insert 沿指定轴将值插入到指定下标之前 delete 删掉某个轴的子数组，并返回删除后的新数组 unique 查找数组内的唯一元素]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>NumPy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python计算环境--NumPy（一）]]></title>
    <url>%2F2019%2F04%2F30%2FPython%E8%AE%A1%E7%AE%97%E7%8E%AF%E5%A2%83-NumPy%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[参考：NumPy 教程：http://www.runoob.com/numpy/numpy-tutorial.htmlNumPy 中文文档：https://www.numpy.org.cn/Pandas 中文文档：https://www.pypandas.cn/Matplotlivb 文档：https://matplotlib.org/ 概述NumPy（Numerical Python）是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库，其中包含： 一个强大的N维数组对象 ndarray 广播功能函数 整合 C/C++/Fortran 代码的工具 线性代数、傅里叶变换、随机数生成等功能 NumPy 通常与 SciPy 和 Matplotlib 一起使用，是一个强大的科学计算环境。 SciPy库 SciPy 是一个开源的 Python 算法库和数学工具包。SciPy 包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算。 Matplotlib库 Matplotlib 是 Python 编程语言及其数值数学扩展包 NumPy 的可视化操作界面。它为利用通用的图形用户界面工具包，如 Tkinter,、wxPython、Qt 或 GTK+ 向应用程序嵌入式绘图提供了应用程序接口（API）。 Ndarray 对象ndarray 对象是一个 N 维数组对象，它是一系列同类型数据的集合，以 0 下标为开始进行集合中元素的索引。 创建数组可以通过numpy模块中的常用的几个函数进行创建ndarray多维数组对象，主要函数如下： array 函数：将输入数据（列表、元组、数组或其他序列类型）转换为 ndarray。要么推断出 dtype，要么显示指定的dtype。默认直接复制输入数据。 numpy.array(object,dtype = None,copy = True,order = None,subok = False, ndmin = 0) ones、ones_like 函数：创建指定长度或者形状的全 1 数组。ones_like 以另一个数组为参数，并跟据其形状和 dtype 创建一个全为 1 的数组。 numpy.ones(shape, dtype = None, order = &#39;C&#39;) zeros、zeros_like 函数：创建指定长度或者形状的全零数组。 numpy.zeros(shape, dtype = float, order = &#39;C&#39;) empty、empty_like 函数：创建一个没有任何具体值的数组（准备地说是创建一些未初始化的ndarray多维数组） 不使用，会产生垃圾值。 numpy.empty(shape, dtype = float, order = &#39;C&#39;) eye、identity 函数：创建一个正方的 N×N 单位矩阵（对角线为1，其余为0）。 eye(N) 一些参数说明 名称 描述 object 数组或嵌套的数列 dtype 数组元素的数据类型，可选 copy 对象是否需要复制，可选 order 创建数组的样式，C为行方向，F为列方向，A为任意方向（默认） subok 默认返回一个与基类类型一致的数组 ndmin 指定生成数组的最小维度 shape 数组形状 从已有的数组创建数组（一些参数已在上表列出）： asarry 函数：将输入转换为 ndarry，如果输入本身就是一个 ndarry 就不进行复制。 numpy.asarray(a, dtype = None, order = None) 参数说明： a：任意形式的输入参数，可以是，列表, 列表的元组, 元组, 元组的元组, 元组的列表，多维数组。 12345678910111213import numpy as np # 示例 x = [1,2,3] a = np.asarray(x) x = (1,2,3) a = np.asarray(x) x = [(1,2,3),(4,5)] a = np.asarray(x)x = [1,2,3] a = np.asarray(x, dtype = float) frombuffer函数：用于实现动态数组，接受 buffer 输入参数，以流的形式读入转化成 ndarray 对象。 numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0) 参数说明： buffer：可以是任意对象，会以流的形式读入。 注：buffer 是字符串的时候，Python3 默认 str 是 Unicode 类型，所以要转成 bytestring 在原 str 前加上 b。 count：读取的数据数量，默认为-1，读取所有数据。 offset：读取的起始位置，默认为0。 1234567import numpy as nps = b'Hello World' a = np.frombuffer(s, dtype = 'S1')print(a)# 结果如下：# [b'H' b'e' b'l' b'l' b'o' b' ' b'W' b'o' b'r' b'l' b'd'] fromiter函数：方法从可迭代对象中建立 ndarray 对象，返回一维数组。 numpy.fromiter(iterable, dtype, count=-1) 参数说明： iterable：可迭代对象 dtype：返回数组的数据类型 count：读取的数据数量，默认为-1，读取所有数据 123456789import numpy as np # 使用 range 函数创建列表对象 list=range(5)it=iter(list) # 使用迭代器创建 ndarray x=np.fromiter(it, dtype=float)print(x) arange 函数：类似于内置的 range，但返回的是一个ndarray而不是列表对象，根据 start 与 stop 指定的范围以及 step 设定的步长，生成一个 ndarray。 numpy.arange(start, stop, step, dtype) 参数说明： | 参数 | 描述 || ——- | :———————————————————-: || start | 起始值，默认为0 || stop | 终止值（不包含） || step | 步长，默认为1 || dtype | 返回ndarray的数据类型，如果没有提供，则会使用输入数据的类型。 | linspace 函数：用于创建一个一维数组，数组是一个等差数列构成的。 np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)| 参数 | 描述 || ———- | ———————————————————— || start | 序列的起始值 || stop | 序列的终止值，如果endpoint为true，该值包含于数列中 || num | 要生成的等步长的样本数量，默认为50 || endpoint | 该值为 ture 时，数列中中包含stop值，反之不包含，默认是True。 || retstep | 如果为 True 时，生成的数组中会显示间距，反之不显示。 || dtype | ndarray 的数据类型 | logspace 函数：用于创建一个于等比数列。 np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None) base 参数意思是取对数的时候 log 的下标。 | 参数 | 描述 || ———- | ———————————————————— || start | 序列的起始值为：base start || stop | 序列的终止值为：base stop。如果endpoint为true，该值包含于数列中 || num | 要生成的等步长的样本数量，默认为50 || endpoint | 该值为 ture 时，数列中中包含stop值，反之不包含，默认是True。 || base | 对数 log 的底数。 || dtype | ndarray 的数据类型 | 数据类型（dtype）通过astype方法显式地转换dtype 12345678import numpy as nparr = np.array([[1,2,3],[2,3,4],[3,4,5]]) # 创建数组arr.dtype # 返回数组类型，此时应为'int64' # 转换数据类型 float_arr = arr.dtype(np.float64)arr.dtype # 返回数组类型，此时应为'float64' 数组属性 属性 说明 ndarray.ndim 秩，即轴的数量或维度的数量 ndarray.shape 数组的维度，对于矩阵，n 行 m 列 &amp; 调整数组大小 ndarray.size 数组元素的总个数，相当于 .shape 中 n×m 的值 ndarray.dtype ndarray 对象的元素类型 ndarray.itemsize ndarray 对象中每个元素的大小，以字节为单位 ndarray.flags ndarray 对象的内存信息 ndarray.real ndarray元素的实部 ndarray.imag ndarray 元素的虚部 ndarray.data 包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性 特殊例子： 1234567&gt; import numpy as np &gt; &gt; a = np.array([[1,2,3],[4,5,6]]) &gt; print (a.shape)&gt; b = a.reshape(3,2)&gt; a.shape = (3,2)&gt; 切片和索引与 python 中列表操作相同：start:stop:step 高级索引整数数组索引1234567891011121314151617import numpy as np x = np.array([[ 0, 1, 2],[ 3, 4, 5],[ 6, 7, 8],[ 9, 10, 11]]) print ('我们的数组是：' )print (x)print ('\n')rows = np.array([[0,0],[3,3]]) cols = np.array([[0,2],[0,2]]) y = x[rows,cols] print ('这个数组的四个角元素是：')print (y)a = np.array([[1,2,3], [4,5,6],[7,8,9]])b = a[1:3, 1:3]c = a[1:3,[1,2]]print(b)print(c) 布尔索引123456789import numpy as np x = np.array([[ 0, 1, 2],[ 3, 4, 5],[ 6, 7, 8],[ 9, 10, 11]]) print ('我们的数组是：')print (x)print ('\n')# 现在我们会打印出大于 5 的元素 print ('大于 5 的元素是：')print (x[x &gt; 5]) 12345678910import numpy as np# 使用了 ~（取补运算符）来过滤 NaNa = np.array([np.nan, 1,2,np.nan,3,4,5]) print(a) print (a[~np.isnan(a)])# 滤掉非复数元素a = np.array([1, 2+6j, 5, 3.5+5j]) print (a[np.iscomplex(a)]) 花式索引1234567891011import numpy as np # 取行元素x=np.arange(32).reshape((8,4))print(x)print('\n')print (x[[4,2,1,7]]) # 取4、2、1、7行（从0行开始）print('\n')print (x[[-4,-2,-1,-7]]) # 同理print('\n')print (x[np.ix_([1,5,7,2],[0,3,1,2])]) # 先取行，接着调整行的顺序 广播（Broadcast）广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式，对数组的算术运算通常在相应的元素上进行。 如果两个数组 a 和 b 形状相同，即满足 a.shape == b.shape，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。 123456import numpy as np a = np.array([1,2,3,4]) b = np.array([10,20,30,40]) c = a * b print (c) 当运算中的 2 个数组的形状不同时，numpy 将自动触发广播机制。 12345678910111213a = np.array([[ 0, 0, 0], [10,10,10], [20,20,20], [30,30,30]])b = np.array([1,2,3])# 广播机制：# tile 函数将扩充为4行1列# 与a数组形状相同# bb = np.tile(b, (4, 1))# print(a+bb)print(a + b) 广播的规则: 让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。 输出数组的形状是输入数组形状的各个维度上的最大值。 如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。 当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。 简单理解：对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足： 数组拥有相同形状。 当前维度的值相等。 当前维度的值有一个是 1。 若条件不满足，抛出 “ValueError: frames are not aligned” 异常。 Numpy 读写Numpy 可以读写磁盘上的文本数据或二进制数据。 NumPy 为 ndarray 对象引入了一个简单的文件格式：npy。 npy 文件用于存储重建 ndarray 所需的数据、图形、dtype 和其他信息。 常用的 IO 函数有： load() 和 save() 函数是读写文件数组数据的两个主要函数，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为 .npy 的文件中。 savze() 函数用于将多个数组写入文件，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为 .npz 的文件中。 loadtxt() 和 savetxt() 函数处理正常的文本文件(.txt 等) numpy.save()numpy.save() 函数将数组保存到以 .npy 为扩展名的文件中。 1numpy.save(file, arr, allow_pickle=True, fix_imports=True) 参数说明： file：要保存的文件，扩展名为 .npy，如果文件路径末尾没有扩展名 .npy，该扩展名会被自动加上。 arr: 要保存的数组 allow_pickle: 可选，布尔值，允许使用 Python pickles 保存对象数组，Python 中的 pickle 用于在保存到磁盘文件或从磁盘文件读取之前，对对象进行序列化和反序列化。 fix_imports: 可选，为了方便 Pyhton2 中读取 Python3 保存的数据 123456789import numpy as np a = np.array([1,2,3,4,5]) # 保存到 outfile.npy 文件上np.save('outfile.npy',a) # 保存到 outfile2.npy 文件上，如果文件路径末尾没有扩展名 .npy，该扩展名会被自动加上np.save('outfile2',a) numpy.load()1234import numpy as np b = np.load('outfile.npy') print (b) numpy.savez()1numpy.savez(file, *args, **kwds) 参数说明： file：要保存的文件，扩展名为 .npz，如果文件路径末尾没有扩展名 .npz，该扩展名会被自动加上。 args：要保存的数组，可以使用关键字参数为数组起一个名字，非关键字参数传递的数组会自动起名为 arr_0, arr_1, … 。 kwds：要保存的数组使用关键字名称 123456789101112import numpy as np a = np.array([[1,2,3],[4,5,6]])b = np.arange(0, 1.0, 0.1)c = np.sin(b)# c 使用了关键字参数 sin_arraynp.savez("runoob.npz", a, b, sin_array = c)r = np.load("runoob.npz") print(r.files) # 查看各个数组名称print(r["arr_0"]) # 数组 aprint(r["arr_1"]) # 数组 bprint(r["sin_array"]) # 数组 c savetxt() &amp; loadtxt()savetxt() 函数是以简单的文本文件格式存储数据，对应的使用 loadtxt() 函数来获取数据。 12np.loadtxt(FILENAME, dtype=int, delimiter=' ')np.savetxt(FILENAME, a, fmt="%d", delimiter=",") 1234567import numpy as np a = np.array([1,2,3,4,5]) np.savetxt('out.txt',a) b = np.loadtxt('out.txt') print(b)]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>NumPy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python计算环境--NumPy（三）]]></title>
    <url>%2F2019%2F04%2F30%2FPython%E8%AE%A1%E7%AE%97%E7%8E%AF%E5%A2%83-NumPy%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数学函数三角函数NumPy 提供了标准的三角函数：sin()、cos()、tan()。arcsin，arccos，和 arctan 函数返回给定角度的 sin，cos 和 tan 的反三角函数。这些函数的结果可以通过 numpy.degrees() 函数将弧度转换为角度。 舍入函数四舍五入：numpy.around()1numpy.around(a,decimals) 向下取整：numpy.floor()1numpy.floor(a,decimals) numpy.ceil()1numpy.ceil(a,decimals) 算数函数加减乘除：numpy.add()numpy.subtract()numpy.multiply()numpy.divide()123456789101112131415161718192021import numpy as npa = np.arange(9, dtype = np.float_).reshape(3,3) print ('第一个数组：')print (a)print ('\n')print ('第二个数组：')b = np.array([10,10,10]) print (b)print ('\n')print ('两个数组相加：')print (np.add(a,b))print ('\n')print ('两个数组相减：')print (np.subtract(a,b))print ('\n')print ('两个数组相乘：')print (np.multiply(a,b))print ('\n')print ('两个数组相除：')print (np.divide(a,b)) 倒数：numpy.reciprocal()numpy.reciprocal() 函数返回参数逐元素的倒数。 对数：numpy.power()numpy.power() 函数将第一个输入数组中的元素作为底数，计算它与第二个输入数组中相应元素的幂。 相除取余：numpy.mod()numpy.remainder()计算输入数组中相应元素的相除后的余数 统计函数numpy.amin() &amp; numpy.amax()numpy.amin() 用于计算数组中的元素沿指定轴的最小值。numpy.amax() 用于计算数组中的元素沿指定轴的最大值 numpy.ptp()numpy.ptp()函数计算数组中元素最大值与最小值的差（最大值 - 最小值）。 numpy.percentile()百分位数是统计中使用的度量，表示小于这个值的观察值的百分比。 函数numpy.percentile()接受以下参数。1numpy.percentile(a, q, axis) 参数说明： a: 输入数组 q: 要计算的百分位数，在 0 ~ 100 之间 axis: 沿着它计算百分位数的轴 首先明确百分位数：第 p 个百分位数是这样一个值，它使得至少有 p% 的数据项小于或等于这个值，且至少有 (100-p)% 的数据项大于或等于这个值。举个例子：高等院校的入学考试成绩经常以百分位数的形式报告。比如，假设某个考生在入学考试中的语文部分的原始分数为 54 分。相对于参加同一考试的其他学生来说，他的成绩如何并不容易知道。但是如果原始分数54分恰好对应的是第70百分位数，我们就能知道大约70%的学生的考分比他低，而约30%的学生考分比他高。这里的 p = 70。 123456789101112131415161718import numpy as np a = np.array([[10, 7, 4], [3, 2, 1]])print ('我们的数组是：')print (a) print ('调用 percentile() 函数：')# 50% 的分位数，就是 a 里排序之后的中位数print (np.percentile(a, 50)) # axis 为 0，在纵列上求print (np.percentile(a, 50, axis=0)) # axis 为 1，在横行上求print (np.percentile(a, 50, axis=1)) # 保持维度不变print (np.percentile(a, 50, axis=1, keepdims=True)) 输出结果为：123456789我们的数组是：[[10 7 4] [ 3 2 1]]调用 percentile() 函数：3.5[6.5 4.5 2.5][7. 2.][[7.] [2.]] numpy.median()numpy.median() 函数用于计算数组 a 中元素的中位数（中值）12345678910111213141516import numpy as np a = np.array([[30,65,70],[80,95,10],[50,90,60]]) print ('我们的数组是：') print (a) print ('\n') print ('调用 median() 函数：') print (np.median(a)) print ('\n') print ('沿轴 0 调用 median() 函数：') print (np.median(a, axis = 0)) print ('\n') print ('沿轴 1 调用 median() 函数：') print (np.median(a, axis = 1)) 输出结果为： 12345678910111213141516我们的数组是：[[30 65 70] [80 95 10] [50 90 60]]调用 median() 函数：65.0沿轴 0 调用 median() 函数：[50. 90. 60.]沿轴 1 调用 median() 函数：[65. 80. 60.] numpy.mean()numpy.mean() 函数返回数组中元素的算术平均值。 如果提供了轴，则沿其计算。 算术平均值是沿轴的元素的总和除以元素的数量。12345678910111213141516import numpy as np a = np.array([[1,2,3],[3,4,5],[4,5,6]]) print ('我们的数组是：') print (a) print ('\n') print ('调用 mean() 函数：') print (np.mean(a)) print ('\n')print ('沿轴 0 调用 mean() 函数：') print (np.mean(a, axis = 0)) print ('\n') print ('沿轴 1 调用 mean() 函数：') print (np.mean(a, axis = 1)) 输出结果为： 12345678910111213141516我们的数组是：[[1 2 3] [3 4 5] [4 5 6]]调用 mean() 函数：3.6666666666666665沿轴 0 调用 mean() 函数：[2.66666667 3.66666667 4.66666667]沿轴 1 调用 mean() 函数：[2. 4. 5.] numpy.average()numpy.average() 函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。 该函数可以接受一个轴参数。 如果没有指定轴，则数组会被展开。 加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数。 考虑数组[1,2,3,4]和相应的权重[4,3,2,1]，通过将相应元素的乘积相加，并将和除以权重的和，来计算加权平均值。 1加权平均值 = (1*4+2*3+3*2+4*1)/(4+3+2+1) 12345678910111213141516171819import numpy as np a = np.array([1,2,3,4]) print ('我们的数组是：') print (a) print ('\n') print ('调用 average() 函数：') print (np.average(a)) print ('\n') # 不指定权重时相当于 mean 函数 wts = np.array([4,3,2,1]) print ('再次调用 average() 函数：') print (np.average(a,weights = wts)) print ('\n') # 如果 returned 参数设为 true，则返回权重的和 print ('权重的和：') print (np.average([1,2,3,4],weights = [4,3,2,1], returned = True)) 输出结果为： 1234567891011我们的数组是：[1 2 3 4]调用 average() 函数：2.5再次调用 average() 函数：2.0权重的和：(2.0, 10.0) 在多维数组中，可以指定用于计算的轴。 123456789101112import numpy as np a = np.arange(6).reshape(3,2) print ('我们的数组是：') print (a) print ('\n') print ('修改后的数组：') wt = np.array([3,5]) print (np.average(a, axis = 1, weights = wt)) print ('\n') print ('修改后的数组：') print (np.average(a, axis = 1, weights = wt, returned = True)) 输出结果为： 12345678910我们的数组是：[[0 1] [2 3] [4 5]]修改后的数组：[0.625 2.625 4.625]修改后的数组：(array([0.625, 2.625, 4.625]), array([8., 8., 8.])) 标准差标准差是一组数据平均值分散程度的一种度量。 标准差是方差的算术平方根。 标准差公式如下： 1std = sqrt(mean((x - x.mean())**2)) 如果数组是 [1，2，3，4]，则其平均值为 2.5。 因此，差的平方是 [2.25,0.25,0.25,2.25]，并且其平均值的平方根除以 4，即 sqrt(5/4) ，结果为 1.1180339887498949。 12import numpy as np print (np.std([1,2,3,4])) 输出结果为： 11.1180339887498949 方差统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数，即 mean((x - x.mean())** 2)。 换句话说，标准差是方差的平方根。 12import numpy as np print (np.var([1,2,3,4])) 输出结果为： 11.25 排序、条件筛选函数NumPy 提供了多种排序的方法。 这些排序函数实现不同的排序算法，每个排序算法的特征在于执行速度，最坏情况性能，所需的工作空间和算法的稳定性。 下表显示了三种排序算法的比较。 种类 速度 最坏情况 工作空间 稳定性 quicksort（快速排序） 1 O(n^2) 0 否 mergesort（归并排序） 2 O(n*log(n)) ~n/2 是 heapsort（堆排序） 3 O(n*log(n)) 0 否 numpy.sort()numpy.sort() 函数返回输入数组的排序副本。函数格式如下： 1numpy.sort(a, axis, kind, order) 参数说明： a: 要排序的数组 axis: 沿着它排序数组的轴，如果没有数组会被展开，沿着最后的轴排序， axis=0 按列排序，axis=1 按行排序 kind: 默认为’quicksort’（快速排序） order: 如果数组包含字段，则是要排序的字段 1234567891011121314151617181920212223import numpy as np a = np.array([[3,7],[9,1]]) print ('我们的数组是：') print (a) print ('\n') print ('调用 sort() 函数：') print (np.sort(a)) print ('\n') print ('按列排序：') print (np.sort(a, axis = 0)) print ('\n')# 在 sort 函数中排序字段 dt = np.dtype([('name', 'S10'),('age', int)]) a = np.array([("raju",21),("anil",25),("ravi", 17), ("amar",27)], dtype = dt) print ('我们的数组是：') print (a) print ('\n')print ('按 name 排序：') print (np.sort(a, order = 'name')) 输出结果为： 1234567891011121314151617我们的数组是：[[3 7] [9 1]]调用 sort() 函数：[[3 7] [1 9]]按列排序：[[3 1] [9 7]]我们的数组是：[(b'raju', 21) (b'anil', 25) (b'ravi', 17) (b'amar', 27)]按 name 排序：[(b'amar', 27) (b'anil', 25) (b'raju', 21) (b'ravi', 17)] numpy.argsort()numpy.argsort() 函数返回的是数组值从小到大的索引值。1234567891011121314151617import numpy as np x = np.array([3, 1, 2]) print ('我们的数组是：') print (x) print ('\n') print ('对 x 调用 argsort() 函数：') y = np.argsort(x) print (y) print ('\n') print ('以排序后的顺序重构原数组：') print (x[y]) print ('\n') print ('使用循环重构原数组：') for i in y: print (x[i], end=" ") 输出结果为： 1234567891011我们的数组是：[3 1 2]对 x 调用 argsort() 函数：[1 2 0]以排序后的顺序重构原数组：[1 2 3]使用循环重构原数组1 2 3 numpy.lexsort()numpy.lexsort() 用于对多个序列进行排序。把它想象成对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。这里举一个应用场景：小升初考试，重点班录取学生按照总成绩录取。在总成绩相同时，数学成绩高的优先录取，在总成绩和数学成绩都相同时，按照英语成绩录取…… 这里，总成绩排在电子表格的最后一列，数学成绩在倒数第二列，英语成绩在倒数第三列。 123456789import numpy as np nm = ('raju','anil','ravi','amar') dv = ('f.y.', 's.y.', 's.y.', 'f.y.') ind = np.lexsort((dv,nm)) print ('调用 lexsort() 函数：') print (ind) print ('\n') print ('使用这个索引来获取排序后的数据：') print ([nm[i] + ", " + dv[i] for i in ind]) 输出结果为： 12345调用 lexsort() 函数：[3 1 0 2]使用这个索引来获取排序后的数据：['amar, f.y.', 'anil, s.y.', 'raju, f.y.', 'ravi, s.y.'] 上面传入 np.lexsort 的是一个tuple，排序时首先排 nm，顺序为：amar、anil、raju、ravi 。综上排序结果为 [3 1 0 2]。 msort、sort_complex、partition、argpartition 函数 描述 msort(a) 数组按第一个轴排序，返回排序后的数组副本。np.msort(a) 相等于 np.sort(a, axis=0)。 sort_complex(a) 对复数按照先实部后虚部的顺序进行排序。 partition(a, kth[, axis, kind, order]) 指定一个数，对数组进行分区 argpartition(a, kth[, axis, kind, order]) 可以通过关键字 kind 指定算法沿着指定轴对数组进行分区 复数排序： 123456&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.sort_complex([5, 3, 6, 2, 1])array([ 1.+0.j, 2.+0.j, 3.+0.j, 5.+0.j, 6.+0.j])&gt;&gt;&gt;&gt;&gt;&gt; np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j])array([ 1.+2.j, 2.-1.j, 3.-3.j, 3.-2.j, 3.+5.j]) partition() 分区排序： 123456&gt;&gt;&gt; a = np.array([3, 4, 2, 1])&gt;&gt;&gt; np.partition(a, 3) # 将数组 a 中所有元素（包括重复元素）从小到大排列，比第3小的放在前面，大的放在后面array([2, 1, 3, 4])&gt;&gt;&gt;&gt;&gt;&gt; np.partition(a, (1, 3)) # 小于 1 的在前面，大于 3 的在后面，1和3之间的在中间array([1, 2, 3, 4]) 找到数组的第 3 小（index=2）的值和第 2 大（index=-2）的值 12345&gt;&gt;&gt; arr = np.array([46, 57, 23, 39, 1, 10, 0, 120])&gt;&gt;&gt; arr[np.argpartition(arr, 2)[2]]10&gt;&gt;&gt; arr[np.argpartition(arr, -2)[-2]]57 同时找到第 3 和第 4 小的值。注意这里，用 [2,3] 同时将第 3 和第 4 小的排序好，然后可以分别通过下标 [2] 和 [3] 取得。 1234&gt;&gt;&gt; arr[np.argpartition(arr, [2,3])[2]]10&gt;&gt;&gt; arr[np.argpartition(arr, [2,3])[3]]23 numpy.argmax() 和 numpy.argmin()numpy.argmax() 和 numpy.argmin()函数分别沿给定轴返回最大和最小元素的索引。123456789101112131415161718192021222324252627282930313233import numpy as np a = np.array([[30,40,70],[80,20,10],[50,90,60]]) print ('我们的数组是：') print (a) print ('\n') print ('调用 argmax() 函数：') print (np.argmax(a)) print ('\n') print ('展开数组：') print (a.flatten()) print ('\n') print ('沿轴 0 的最大值索引：') maxindex = np.argmax(a, axis = 0) print (maxindex) print ('\n') print ('沿轴 1 的最大值索引：') maxindex = np.argmax(a, axis = 1) print (maxindex) print ('\n') print ('调用 argmin() 函数：') minindex = np.argmin(a) print (minindex) print ('\n') print ('展开数组中的最小值：') print (a.flatten()[minindex]) print ('\n') print ('沿轴 0 的最小值索引：') minindex = np.argmin(a, axis = 0) print (minindex) print ('\n') print ('沿轴 1 的最小值索引：') minindex = np.argmin(a, axis = 1) print (minindex) 输出结果为： 12345678910111213141516171819202122232425262728我们的数组是：[[30 40 70] [80 20 10] [50 90 60]]调用 argmax() 函数：7展开数组：[30 40 70 80 20 10 50 90 60]沿轴 0 的最大值索引：[1 2 0]沿轴 1 的最大值索引：[2 0 1]调用 argmin() 函数：5展开数组中的最小值：10沿轴 0 的最小值索引：[0 1 1]沿轴 1 的最小值索引：[0 2 0] numpy.nonzero()numpy.nonzero() 函数返回输入数组中非零元素的索引。1234567import numpy as np a = np.array([[30,40,0],[0,20,10],[50,0,60]]) print ('我们的数组是：') print (a) print ('\n') print ('调用 nonzero() 函数：') print (np.nonzero (a)) 输出结果为： 1234567我们的数组是：[[30 40 0] [ 0 20 10] [50 0 60]]调用 nonzero() 函数：(array([0, 0, 1, 1, 2, 2]), array([0, 1, 1, 2, 0, 2])) numpy.where()numpy.where() 函数返回输入数组中满足给定条件的元素的索引。 123456789import numpy as np x = np.arange(9.).reshape(3, 3) print ('我们的数组是：') print (x) print ( '大于 3 的元素的索引：') y = np.where(x &gt; 3) print (y) print ('使用这些索引来获取满足条件的元素：') print (x[y]) 输出结果为： 12345678我们的数组是：[[0. 1. 2.] [3. 4. 5.] [6. 7. 8.]]大于 3 的元素的索引：(array([1, 1, 2, 2, 2]), array([1, 2, 0, 1, 2]))使用这些索引来获取满足条件的元素：[4. 5. 6. 7. 8.] numpy.extract()numpy.extract() 函数根据某个条件从数组中抽取元素，返回满条件的元素。12345678910import numpy as np x = np.arange(9.).reshape(3, 3) print ('我们的数组是：') print (x) # 定义条件, 选择偶数元素 condition = np.mod(x,2) == 0 print ('按元素的条件值：') print (condition) print ('使用条件提取元素：') print (np.extract(condition, x)) 输出结果为：12345678910我们的数组是：[[0. 1. 2.] [3. 4. 5.] [6. 7. 8.]]按元素的条件值：[[ True False True] [False True False] [ True False True]]使用条件提取元素：[0. 2. 4. 6. 8.]]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>NumPy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['Python绘图库-Matplotlib']]></title>
    <url>%2F2019%2F04%2F26%2FPython%E7%BB%98%E5%9B%BE%E5%BA%93-Matplotlib%2F</url>
    <content type="text"><![CDATA[Matplotlib 是一个Python 2D 绘图库，可生成绘图，直方图，功率谱，条形图，错误图，散点图等。 图的部分下图介绍了 Matplotlib 绘制图的关键部分： 绘图程序12345678910111213141516171819202122232425# ------------------------------# 程序1：Matplotlib基本绘图# ------------------------------import matplotlib.pyplot as pltimport numpy as npimport randomdata1, data2, data3, data4 = np.random.randn(4, 100）# 在图fig中以2×2格式4子坐标轴# 坐标轴名称的排列形式需要与生成子图排列形式相同fig,([ax1,ax2],[ax3,ax4]) = plt.subplots(2,2)# 在坐标轴ax1中绘图ax1.plot(data1,data2,'x')# 在坐标轴ax2中绘图ax2.plot(data3,data4,'o')# 在坐标轴ax3中绘图# 无x轴数据，自动扩展为[0,1,2,3]ax3.plot([0,2,5,9],'r')# 在坐标轴ax4中绘图ax4.plot([0,2,5,9],[0,4,25,91],'g')# 展示绘图plt.show() 程序结果如下： 样式说明坐标轴范围1234567# 程序2：设置坐标轴范围import matplotlib.pyplot as pltimport numpy as npplt.plot()plt.axis([0,6,0,20])plt.show() 程序结果如下： 在一个图中绘制多个线条12345678910111213# 程序3import numpy as np# evenly sampled time at 200ms intervalst = np.arange(0., 5., 0.2)# red dashes, blue squares and green trianglesplt.plot(t, t, 'r--', t, t**2, 'bs', t, t**3, 'g^')# 上行效果与下面三行相同# plt.plot(t, t, 'r--')# plt.plot(t, t**2, 'bs')# plt.plot(t, t**3, 'g^')plt.show() 程序结果如下： 使用文本 pyplot API 命令 描述 text text 在任意位置添加文本 annotatle annotatle 使用可选箭头在任意位置添加注释 xlabel set_xlabel 在x轴上添加标签 ylabel set_ylabel 在y轴上添加标签 title set_title 添加标题 figtext text 在任意位置添加文本 suptitle suptitle 添加子标题 123456789101112131415161718192021222324252627282930313233343536373839# 程序4：各种文本的样式import matplotlibimport matplotlib.pyplot as plt# 加粗黑体标题fig = plt.figure()fig.suptitle('bold figure suptitle', fontsize=14, fontweight='bold')# 设置坐标轴标题ax = fig.add_subplot(111)fig.subplots_adjust(top=0.85)ax.set_title('axes title')# 设置坐标轴文本ax.set_xlabel('xlabel')ax.set_ylabel('ylabel')# 任意处添加文本# 盒子样式ax.text(3, 8, 'boxed italics text in data coords', style='italic', bbox=&#123;'facecolor': 'red', 'alpha': 0.5, 'pad': 10&#125;)# 公式样式ax.text(2, 6, r'an equation: $E=mc^2$', fontsize=15)# 默认样式ax.text(3, 2, 'unicode: Institut für Festkörperphysik')# 位置ax.text(0.95, 0.01, 'colored text in axes coords', verticalalignment='bottom', horizontalalignment='right', transform=ax.transAxes, color='green', fontsize=15)# 画了一个点，并使用箭头添加了注释ax.plot([2], [1], 'o')ax.annotate('annotate', xy=(2, 1), xytext=(3, 4), arrowprops=dict(facecolor='black', shrink=0.05))ax.axis([0, 10, 0, 10])plt.show() 更多更多样式和深层次的应用请参考官方文档： https://matplotlib.org/tutorials/introductory/sample_plots.html]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客新增/删除文章]]></title>
    <url>%2F2019%2F04%2F17%2Fhexo%E5%8D%9A%E5%AE%A2%E6%96%B0%E5%A2%9E-%E5%88%A0%E9%99%A4%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[成功搭建好了以hexo为框架的个人博客，并且成功的将其部署在github网站上，地址为：https://jiaxincn.github.io，接下来就要对个人博客进行管理和更新了。 搭建过程请参考 NexT主题 文档：http://theme-next.iissnan.com/ 删除文章以建立hexo个人博客的时候创建的文章 Hellow World 为例说明删除文章的过程： 删除本地文件进入到 \sourse\_post 文件夹下，找到hellowworld.md 文件，执行本地删除； 生成静态文件启动命令行，进入 blog 文件夹中，在命令行中执行如下命令： 1hexo g 小提示：在某些情况，如果发现您对站点的更改无论如何也不生效，您可能需要运行 clean 命令hexo clean 将博客部署到 github 上启动命令行，进入 blog 文件夹中，在命令行中执行如下命令：1hexo d 创建文章创建文章的方法与删除文章类似，具体过程如下： 创建本地博客文章启动命令行，进入 blog 文件夹中，在命令行中执行如下命令： 1hexo new "My New Post" 编写博客文章在 \sourse\_post 中，找到新建的文章 My New Post，使用编辑器编写博客文章； 生成静态文件步骤与删除文件中步骤 2 相同； 12hexo cleanhexo g 将博客部署到 github 上步骤与删除文件中步骤 3 相同； 1hexo d]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
